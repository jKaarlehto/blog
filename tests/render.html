<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>CRT Simulation - Fixed</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <style>
    body {
      background: #111;
      color: white;
      font-family: sans-serif;
      padding: 40px;
      margin: 0;
    }
    #targetElement {
      background: white;
      color: black;
      padding: 20px;
      width: 600px;
      font-size: 18px;
      margin-bottom: 20px;
      border-radius: 8px;
    }
    #crtCanvas {
      display: block;
      margin-top: 30px;
      width: 100%;
      max-width: 800px;
      background: black;
      border-radius: 12px;
      border: 2px solid #333;
    }
    #status {
      margin-top: 10px;
      font-size: 14px;
      color: #888;
    }
  </style>
</head>
<body>
  <div id="targetElement">
    <h1>Hello CRT!</h1>
    <p>This HTML element is rendered to canvas with WebGL CRT effects.</p>
    <p>You should see scanlines, curvature, RGB shift, and vintage monitor effects.</p>
  </div>

  <canvas id="crtCanvas"></canvas>
  <div id="status">Initializing...</div>

  <script>
    const targetElement = document.getElementById('targetElement');
    const crtCanvas = document.getElementById('crtCanvas');
    const statusDiv = document.getElementById('status');

    let gl, program, texture;
    let bufferCanvas;
    let time = 0;
    let animationId;

    const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    const flickerSpeed = isSafari ? 240.0 : 120.0;

    // Fixed vertex shader - proper attribute locations
    const vertexShaderSource = `
      attribute vec2 a_position;
      attribute vec2 a_texCoord;
      varying vec2 v_texCoord;
      void main() {
        gl_Position = vec4(a_position, 0.0, 1.0);
        v_texCoord = a_texCoord;
      }
    `;

    // Optimized fragment shader with better effects
    const fragmentShaderSource = `
      precision mediump float;
      uniform sampler2D u_texture;
      uniform float u_time;
      uniform vec2 u_resolution;
      varying vec2 v_texCoord;

      // CRT screen curvature
      vec2 curve(vec2 uv) {
        uv = (uv - 0.5) * 2.0;
        uv *= 1.05; // Less aggressive curvature
        uv.x *= 1.0 + pow(abs(uv.y) / 4.0, 2.0);
        uv.y *= 1.0 + pow(abs(uv.x) / 5.0, 2.0);
        return uv * 0.5 + 0.5;
      }

      // Scanlines effect
      float scanline(vec2 uv) {
        return sin(uv.y * u_resolution.y * 1.2) * 0.04;
      }

      // RGB chromatic aberration
      vec3 rgbShift(sampler2D tex, vec2 uv) {
        float shift = 0.001;
        float r = texture2D(tex, uv + vec2(shift, 0.0)).r;
        float g = texture2D(tex, uv).g;
        float b = texture2D(tex, uv - vec2(shift, 0.0)).b;
        return vec3(r, g, b);
      }

      // Vignette effect
      float vignette(vec2 uv) {
        uv *= 1.0 - uv.yx;
        float vig = uv.x * uv.y * 12.0;
        return pow(vig, 0.2);
      }

      // CRT noise
      float noise(vec2 uv) {
        return fract(sin(dot(uv + u_time, vec2(12.9898, 78.233))) * 43758.5453);
      }

      void main() {
        vec2 uv = curve(v_texCoord);
        
        // Check bounds after curvature
        if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
          return;
        }

        // Sample the texture with RGB shift
        vec3 color = rgbShift(u_texture, uv);
        
        // Apply scanlines
        color -= scanline(uv);
        
        // Apply vignette
        color *= vignette(v_texCoord); // Use original UV for vignette
        
        // Add noise
        color += noise(uv) * 0.03;
        
        // Green tint (classic CRT monitors)
        color += vec3(0.0, 0.01, 0.0);
        
        // Flicker effect
        color *= 0.97 + 0.03 * sin(u_time * ${flickerSpeed}.0);
        
        // Ensure minimum brightness
        color = max(color, vec3(0.0));
        
        gl_FragColor = vec4(color, 1.0);
      }
    `;

    function createShader(type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
        statusDiv.textContent = 'Shader compilation failed';
        return null;
      }
      return shader;
    }

    function initWebGL() {
      gl = crtCanvas.getContext('webgl') || crtCanvas.getContext('experimental-webgl');
      
      if (!gl) {
        statusDiv.textContent = 'WebGL not supported';
        return false;
      }

      const vs = createShader(gl.VERTEX_SHADER, vertexShaderSource);
      const fs = createShader(gl.FRAGMENT_SHADER, fragmentShaderSource);
      
      if (!vs || !fs) return false;

      program = gl.createProgram();
      gl.attachShader(program, vs);
      gl.attachShader(program, fs);
      gl.linkProgram(program);

      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error('Program linking error:', gl.getProgramInfoLog(program));
        statusDiv.textContent = 'Program linking failed';
        return false;
      }

      gl.useProgram(program);

      // Get attribute locations
      const posLoc = gl.getAttribLocation(program, 'a_position');
      const texLoc = gl.getAttribLocation(program, 'a_texCoord');

      // Create buffer for quad vertices
      const buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        // Position (x,y), TexCoord (u,v)
        -1, -1, 0, 1,  // Bottom-left
         1, -1, 1, 1,  // Bottom-right
        -1,  1, 0, 0,  // Top-left
         1,  1, 1, 0,  // Top-right
      ]), gl.STATIC_DRAW);

      // Set up attributes
      gl.enableVertexAttribArray(posLoc);
      gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 16, 0);
      gl.enableVertexAttribArray(texLoc);
      gl.vertexAttribPointer(texLoc, 2, gl.FLOAT, false, 16, 8);

      // Create texture
      texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

      statusDiv.textContent = 'WebGL initialized successfully';
      return true;
    }

    function updateCRT() {
      if (!gl || !program || !bufferCanvas) return;

      time = performance.now() / 1000.0;

      // Update canvas size
      const displayWidth = Math.min(800, window.innerWidth - 80);
      const displayHeight = (bufferCanvas.height / bufferCanvas.width) * displayWidth;
      
      crtCanvas.style.width = displayWidth + 'px';
      crtCanvas.style.height = displayHeight + 'px';
      crtCanvas.width = bufferCanvas.width;
      crtCanvas.height = bufferCanvas.height;

      gl.viewport(0, 0, crtCanvas.width, crtCanvas.height);

      // Update texture
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, bufferCanvas);

      // Set uniforms
      gl.useProgram(program);
      gl.uniform1f(gl.getUniformLocation(program, 'u_time'), time);
      gl.uniform1i(gl.getUniformLocation(program, 'u_texture'), 0);
      gl.uniform2f(gl.getUniformLocation(program, 'u_resolution'), crtCanvas.width, crtCanvas.height);

      // Clear and draw
      gl.clearColor(0.0, 0.0, 0.0, 1.0);
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

      animationId = requestAnimationFrame(updateCRT);
    }

    function renderAndStart() {
      statusDiv.textContent = 'Rendering HTML to canvas...';
      
      html2canvas(targetElement, {
        backgroundColor: '#ffffff',
        scale: 2,
        useCORS: true,
        allowTaint: true,
        logging: false
      }).then(canvas => {
        bufferCanvas = canvas;
        
        // Set initial canvas size
        crtCanvas.width = canvas.width;
        crtCanvas.height = canvas.height;
        
        statusDiv.textContent = 'CRT effect active!';
        updateCRT();
      }).catch(error => {
        console.error('html2canvas error:', error);
        statusDiv.textContent = 'Failed to render HTML';
      });
    }

    // Initialize everything
    if (initWebGL()) {
      // Wait a bit for fonts and layout to settle
      setTimeout(renderAndStart, 100);
    } else {
      statusDiv.textContent = 'Failed to initialize WebGL';
    }

    // Handle page visibility changes
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        if (animationId) {
          cancelAnimationFrame(animationId);
        }
      } else {
        if (bufferCanvas) {
          updateCRT();
        }
      }
    });
  </script>
</body>
</html>
